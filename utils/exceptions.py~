from typing import Optional, Dict, Any
from utils.logger import TradingLogger


class TradingError(Exception):
    """Базовый класс для всех ошибок торговой системы"""

    def __init__(
            self,
            message: str = "Произошла ошибка в торговой системе",
            details: Optional[Dict[str, Any]] = None,
            logger: Optional[TradingLogger] = None
    ):
        """
        Инициализация торговой ошибки

        Args:
            message: Человеко-читаемое сообщение об ошибке
            details: Дополнительные технические детали ошибки
            logger: Опциональный логгер для автоматического логирования
        """
        self.message = message
        self.details = details or {}
        super().__init__(message)

        if logger:
            self.log_error(logger)

    def log_error(self, logger: TradingLogger) -> None:
        """Логирование ошибки с деталями"""
        log_message = f"{self.__class__.__name__}: {self.message}"
        if self.details:
            log_message += f"\nДетали: {self.details}"
        logger.error(log_message)

    def __str__(self) -> str:
        return f"{self.__class__.__name__}: {self.message}"


class TradingConnectionError(TradingError):
    """Базовый класс для ошибок подключения в торговой системе"""

    def __init__(
            self,
            resource: str,
            reason: str,
            **kwargs
    ):
        message = f"Ошибка подключения к {resource}: {reason}"
        super().__init__(message=message, **kwargs)


class MT5ConnectionError(TradingConnectionError):
    """Ошибка подключения к MetaTrader 5"""

    def __init__(
            self,
            server: str,
            login: int,
            error_code: Optional[int] = None,
            **kwargs
    ):
        details = {
            "server": server,
            "login": login,
            "error_code": error_code
        }
        message = f"Не удалось подключиться к MT5 (сервер: {server}, логин: {login})"
        if error_code:
            message += f", код ошибки: {error_code}"

        super().__init__(
            resource="MetaTrader 5",
            reason=message,
            details=details,
            **kwargs
        )


# Остальные классы исключений остаются без изменений
class StrategyError(TradingError):
    """Базовый класс для ошибок стратегий"""

    def __init__(
            self,
            strategy_name: str,
            **kwargs
    ):
        self.strategy_name = strategy_name
        message = f"Ошибка в стратегии '{strategy_name}'"
        super().__init__(message=message, **kwargs)


class StrategyExecutionError(StrategyError):
    """Ошибка выполнения стратегии"""

    def __init__(
            self,
            strategy_name: str,
            step: str,
            reason: str,
            **kwargs
    ):
        details = {
            "step": step,
            "reason": reason
        }
        message = f"Сбой выполнения стратегии '{strategy_name}' на этапе '{step}': {reason}"
        super().__init__(
            strategy_name=strategy_name,
            message=message,
            details=details,
            **kwargs
        )


class RiskManagementError(TradingError):
    """Базовый класс для ошибок риск-менеджмента"""
    pass

class CredentialsValidationError(TradingError):
    """Ошибка валидации учетных данных"""
    def __init__(self, message: str,
                 details: Optional[Dict[str, Any]] = None,
                 logger: Optional[TradingLogger] = None):
        super().__init__(message=message, details=details, logger=logger)

class RiskValidationError(RiskManagementError):
    """Ошибка валидации параметров риска"""

    def __init__(
            self,
            parameter: str,
            value: Any,
            valid_range: str,
            **kwargs
    ):
        details = {
            "parameter": parameter,
            "value": value,
            "valid_range": valid_range
        }
        message = (f"Недопустимое значение параметра риска '{parameter}': {value}. "
                   f"Допустимый диапазон: {valid_range}")
        super().__init__(message=message, details=details, **kwargs)


class OrderError(TradingError):
    """Базовый класс для ошибок работы с ордерами"""

    def __init__(
            self,
            order_id: Optional[int] = None,
            symbol: Optional[str] = None,
            **kwargs
    ):
        self.order_id = order_id
        self.symbol = symbol
        details = {
            "order_id": order_id,
            "symbol": symbol
        }
        message = "Ошибка работы с ордером"
        if order_id:
            message += f" #{order_id}"
        if symbol:
            message += f" ({symbol})"

        super().__init__(message=message, details=details, **kwargs)


class InsufficientFundsError(OrderError):
    """Недостаточно средств для выполнения операции"""

    def __init__(
            self,
            required: float,
            available: float,
            currency: str,
            **kwargs
    ):
        details = {
            "required": required,
            "available": available,
            "currency": currency
        }
        message = (f"Недостаточно средств. Требуется: {required:.2f} {currency}, "
                   f"доступно: {available:.2f} {currency}")
        super().__init__(message=message, details=details, **kwargs)


class ConfigurationError(TradingError):
    """Ошибка конфигурации приложения"""
    pass


class DatabaseError(TradingError):
    """Базовый класс для ошибок работы с базой данных."""

    def __init__(
            self,
            message: str = "Ошибка работы с базой данных",
            query: Optional[str] = None,
            params: Optional[tuple] = None,
            **kwargs
    ):
        """
        Инициализация ошибки базы данных.

        Args:
            message: Человеко-читаемое сообщение об ошибке
            query: SQL-запрос, вызвавший ошибку (опционально)
            params: Параметры запроса (опционально)
            **kwargs: Дополнительные аргументы для базового класса
        """
        details = kwargs.get('details', {})
        if query:
            details['query'] = query
        if params:
            details['params'] = params

        super().__init__(
            message=message,
            details=details,
            **{k: v for k, v in kwargs.items() if k != 'details'}
        )


class DatabaseConnectionError(DatabaseError):
    """Ошибка подключения к базе данных."""

    def __init__(
            self,
            connection_string: str,
            reason: str,
            **kwargs
    ):
        """
        Инициализация ошибки подключения.

        Args:
            connection_string: Строка подключения к БД
            reason: Причина ошибки
            **kwargs: Дополнительные аргументы
        """
        message = f"Ошибка подключения к БД ({connection_string}): {reason}"
        super().__init__(
            message=message,
            details={
                'connection_string': connection_string,
                'reason': reason
            },
            **kwargs
        )


class DatabaseQueryError(DatabaseError):
    """Ошибка выполнения запроса к базе данных."""

    def __init__(
            self,
            query: str,
            params: Optional[tuple] = None,
            reason: Optional[str] = None,
            **kwargs
    ):
        """
        Инициализация ошибки запроса.

        Args:
            query: SQL-запрос
            params: Параметры запроса (опционально)
            reason: Причина ошибки (опционально)
            **kwargs: Дополнительные аргументы
        """
        message = "Ошибка выполнения запроса к БД"
        if reason:
            message += f": {reason}"

        details = {'query': query}
        if params:
            details['params'] = str(params)  # Преобразуем кортеж в строку

        super().__init__(
            message=message,
            details=details,
            **kwargs
        )